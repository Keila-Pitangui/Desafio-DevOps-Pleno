version: "3"
  #inner version:2.2.0
services:
  
  # blocos que foram inseridos (nginx, prometheus, grafana, loki)
  nginx:
    image: nginx:stable-alpine
    container_name: nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/mime.types:/etc/nginx/mime.types:ro
      - ./certs:/etc/nginx/certs:ro
      - ./logs/nginx:/var/log/nginx
    ports:
      - "80:80"
      - "443:443"
    restart: always
    depends_on:
      - api
      - grafana
      - prometheus
    networks:
      - backend

  grafana:
    image: grafana/grafana:10.4.0
    container_name: grafana
    user: "0" # 
    environment:
      GF_SERVER_DOMAIN: ${GF_SERVER_DOMAIN}
      GF_SERVER_ROOT_URL: ${GF_SERVER_ROOT_URL}
      GF_SERVER_SERVE_FROM_SUB_PATH: ${GF_SERVER_SERVE_FROM_SUB_PATH}
      GF_AUTH_ANONYMOUS_ENABLED: ${GF_AUTH_ANONYMOUS_ENABLED}
      GF_SECURITY_ADMIN_PASSWORD: ${GF_SECURITY_ADMIN_PASSWORD}
    volumes:
      - /grafana:/var/lib/grafana
    networks:
      - backend
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:v3.5.1
    user: "root"
    container_name: prometheus
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./prometheus/alert_rules.yml:/etc/prometheus/alert_rules.yml
      - ./prometheus_data:/prometheus
    # ports:
    #   - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=7d' # no command-line flags vai aparecer como 1w que seria 1 week (1 semana = 7 dias)
      - '--web.external-url=https://api.jimi.local/prometheus/'
      - '--web.route-prefix=/'
    networks:
      - backend
    restart: unless-stopped

  loki:
    image: grafana/loki:3.6
    container_name: loki
    command:
      - "-config.file=/etc/loki/loki.yml"
    volumes:
      - ./loki/loki.yml:/etc/loki/loki.yml
      - ./loki:/loki
    # ports:
    #   - "3100:3100"
    networks:
      - backend
    restart: unless-stopped

  promtail:
    image: grafana/promtail:3.0.0
    container_name: promtail
    user: "0:0"
    privileged: true
    security_opt:
      - label:disable
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./promtail/promtail.yml:/etc/promtail/config.yml
      - /iothub/logs/nginx:/var/log/nginx
      - ./logs/nginx:/var/log/nginx
      - /var/lib/docker/containers:/var/lib/docker/containers
    command: -config.file=/etc/promtail/config.yml
    networks:
      - backend

  #####################################
  # Bloco - Webhook
  webhook:
    build: .
    container_name: webhook
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
    restart: always
    networks:
      - backend
    logging:
      driver: "json-file"
      options:
        tag: "{{.ImageName}}|{{.Name}}|{{.ImageFullID}}|{{.FullID}}"
  ####################################
  
  kafka:
    restart: always
    container_name: kafka
    image: hb.jimiops.top/iothub/jimi-kafka:5.0.3
    # ports:
    #   - "9092:9092"
    volumes:
      - "/iothub/kafka:/kafka"
    environment:
      KAFKA_ADVERTISED_HOST_NAME: ${KAFKA_ADVERTISED_HOST_NAME}
      KAFKA_ZOOKEEPER_CONNECT: ${KAFKA_ZOOKEEPER_CONNECT}
      KAFKA_CFG_LISTENERS: ${KAFKA_CFG_LISTENERS}
      KAFKA_CFG_ADVERTISED_LISTENERS: ${KAFKA_CFG_ADVERTISED_LISTENERS}
      ALLOW_PLAINTEXT_LISTENER: ${ALLOW_PLAINTEXT_LISTENER}
      HOSTNAME: ${HOSTNAME}
    depends_on:
      - zookeeper
    deploy:
      resources:
         limits:
            cpus: '2'
            memory: 2G
         reservations:
            memory: 1G
    networks:
      - backend
  mongodb:
    restart: always
    container_name: mongodb
    image: hb.jimiops.top/iothub/jimi-mongo:5.0.1
    # ports:
    #   - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}
    volumes:
      - "/iothub/mongoDB:/data/db"
    networks:
      - backend
  redis:
    restart: always
    container_name: redis
    image: hb.jimiops.top/iothub/jimi-redis:5.0.1
    # ports:
    #   - "6379:6379"
    volumes:
      - "/iothub/redis:/data"
    command: redis-server --requirepass jimi@123 --appendonly yes
    networks:
      - backend
  zookeeper:
    restart: always
    container_name: zookeeper
    image: hb.jimiops.top/iothub/jimi-zookeeper:5.0.3
    # ports:
    #   - "2181:2181"
    volumes:
      - "/iothub/zookeeper/data:/data"
      - "/iothub/zookeeper/datalog:/datalog"
    environment:
      ALLOW_ANONYMOUS_LOGIN: ${ALLOW_ANONYMOUS_LOGIN}
    networks:
      - backend
  api:
    restart: always
    container_name: api
    image: hb.jimiops.top/iothub/tracker-dvr-api_sa:76268425
    # ports:
    #   - "9080:9080"
    volumes:
      - "/iothub/api/:/app/tracker-dvr-api/logs"
      - "/iothub/api/data/:/app/data" #挂载文件目录
    links:
      - router
      - redis
    depends_on:
      - router
    environment:
      - routeHost=${routeHost}
      - redisHost=${redisHost}
      - redisPassword=${redisPassword}
      - mongoHost=${mongoHost}
      - mongodbUser=${mongodbUser}
      - mongodbPassword=${mongodbPassword}
      #This offlineCmdPushURL is used to receive replies of offline instructions. Please refer to 2.4 for the format. It should be customers' real address!!!
      - offlineCmdPushURL=${offlineCmdPushURL}
      - offlineCmdPushToken=${offlineCmdPushToken}
      # Enable(true)/Disable(false) storage clean up function
      - storageLimit=${storageLimit}
      # Clean up the root directory(including subdirectories)
      - storageLimitPath=${storageLimitPath}
      # System log cleaning time (days)
      - systemLogStorageLimitDays=${systemLogStorageLimitDays}
      # Dump log cleaning time (days)
      - userDataStorageLimitDays=${userDataStorageLimitDays}
      # Media log cleaning time (days)
      - mediaStorageLimitDays=${mediaStorageLimitDays}
      # Enable(true)/Disable(false) push data
      - pushEnable=${pushEnable}
      # push times per day, support 2,3,4,6,8,12,24
      - dayPushTimes=${dayPushTimes}
      # IoTHub metrics push to JIMI URL
      - pushJimiUrl=${pushJimiUrl}
      # Fixed value
      - jimiPushToken=${jimiPushToken}
      # Obtain the URL address for media streaming data
      - mediaServerUrl=${mediaServerUrl}
      # Fixed value
      - mediaServerSecret=${mediaServerSecret}
    networks:
      - backend
  tracker-instruction-server:
    restart: always
    container_name: tracker-instruction-server
    image: hb.jimiops.top/iothub/tracker-instruction-server_sa:76268425
    # ports:
    #   - "10088:10088"
    volumes:
      - "/iothub/tracker-instruction-server/:/app/tracker-instruction-server/logs"
    links:
      - router
      - redis
    depends_on:
      - router
      - redis
    environment:
      - routeHost=${routeHost}
      - redisHost=${redisHost}
      - redisPassword=${redisPassword}
      - redisDB=${redisDB}
      - kafkaHost=${kafkaHost}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      #This offlineCmdPushURL is used to receive replies to offline instructions. Pleaserefer to 2.4 for the format. It should be customers' real address!!!
      - offlineCmdPushURL=${offlineCmdPushURL}
      - offlineCmdPushToken=${offlineCmdPushToken}
      - JVM_OPTS=${JVM_OPTS}
    networks:
      - backend
  msg-dispatch-iothub:
    restart: always
    container_name: msg-dispatch-iothub
    image: hb.jimiops.top/iothub/msg-dispatch-iothub_sa:76268425
    # ports:
    #   - "10066:10066"
    volumes:
      - "/iothub/msg-dispatch-iothub/:/app/msg-dispatch-iothub/logs"
    links:
      - kafka
    depends_on:
      - kafka
    environment:
      - apollo=${apollo}
      - kafkaHost=${kafkaHost}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      - pushURL=${pushURL}
      - pushToken=${pushToken}
     # - emailSendUrl=${emailSendUrl}
      - LICENSE_NOTIFY_EMAIL=${LICENSE_NOTIFY_EMAIL}
      #HTTP push data encrypted switch
      - httpPushEncrypt=${httpPushEncrypt}
      ##Encryption Key
      - httpPushSecret=${httpPushSecret}
      - newMileagePush=${newMileagePush}
      - JVM_OPTS=${JVM_OPTS}
      - logInfo1Enable=${logInfo1Enable}
      - logInfo2Enable=${logInfo2Enable}
      - logInfo3Enable=${logInfo3Enable}
      - redisHost=${redisHost}
      - redisPort=${redisPort}
      - redisPasswd=${redisPasswd}
      # Distinguish whether push heartbeat data or not by gateId, configured by default
      - jttProtocolGate=${jttProtocolGate}
    networks:
      - backend
  dvr-upload:
    restart: always
    container_name: dvr-upload
    image: hb.jimiops.top/iothub/dvr-upload_sa:31e8aa09
    # ports:
    #   - "23010:23010"
    volumes:
      - "/iothub/dvr-upload/logs:/app/dvr-upload/logs"
      - "/iothub/dvr-upload/uploadFile:/data/upload"
      - "/iothub/jimi-upload-process/uploadFile:/data/upload/jtt"
    environment:
      - ENABLE_SECRET=${ENABLE_SECRET}
      - LOCAL_ENABLE=${LOCAL_ENABLE}
      - OSS_ENABLE=${OSS_ENABLE}
      - OSS_ENDPOINT=${OSS_ENDPOINT}
      - OSS_ACCESS_KEY=${OSS_ACCESS_KEY}
      - OSS_BUCKET_NAME=${OSS_BUCKET_NAME}
      - OSS_ACCESS_SECRET=${OSS_ACCESS_SECRET}
      - AWS_ENABLE=${AWS_ENABLE}
      - AWS_REGION=${AWS_REGION}
      - AWS_BUCKET_NAME=${AWS_BUCKET_NAME}
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AZURE_ENABLE=${AZURE_ENABLE}
      - AZURE_BUCKET_NAME=${AZURE_BUCKET_NAME}
      - AZURE_ACCOUNT_NAME=${AZURE_ACCOUNT_NAME}
      - AZURE_ACCESS_KEY_ID=${AZURE_ACCESS_KEY_ID}
      - GCS_ENABLE=${GCS_ENABLE}
      - GCS_BUCKET_NAME=${GCS_BUCKET_NAME}
      - GCS_PROJECT_ID=${GCS_PROJECT_ID}
      - pushURL=${pushURL}
      - pushToken=${pushToken}
      - redisHost=${redisHost}
      - redisPort=${redisPort}
      - redisPasswd=${redisPasswd}
    networks:
      - backend
  tracker-gate-v1:
    restart: always
    container_name: tracker-gate-v1
    image: hb.jimiops.top/iothub/tracker-gate-v1_sa:0a5e9d8c
    # ports:
    #   - "21100:21100"
    volumes:
      - "/iothub/license:/app/tracker-gate-v1/conf/license"
      - "/iothub/tracker-gate-v1/logs:/app/tracker-gate-v1/logs"
    links:
      - router
      - redis
    depends_on:
      - router
    environment:
      - gateId=tracker-gate-v1-93
      - routeHost=router
      - redisHost=redis
      - redisPort=6379
      - redisPassword=jimi@123
      - kafkaHost=kafka:9092
      - kafkaAuthSwitch=false
      - kafkaAuthUserName=admin
      - kafkaAuthPassword=123456
      - kafkaEnable=true
        #LBS value-added service, please contact customer service to open!
      - lbsURL=http://xxx
      - lbsToken=a3bfe487e6ae029fb02402e6cb2ceacc
      - logInfo1Enable=true
      - logInfo2Enable=true
      - logInfo3Enable=true
      - checkDeviceImport=false
      - reloadImei=false
      # Enable(true)/Disable(false) metric collection in IoTHub's monitoring settings
      - collectIothubMetric=false
      # If router initialization fails, wait for 3 seconds and retry
      - hbConnectionFailedSleep=false
    networks:
      - backend
  jimi-gateway-v541h:
    restart: always
    container_name: jimi-gateway-v541h
    image: hb.jimiops.top/iothub/tracker-gate-v541h_sa:8c360419
    # ports:
    #   - "31506:31506"
    volumes:
      - "/iothub/license/:/app/tracker-gate-v541h/conf/license/"
      - "/iothub/tracker-gate-v541h/logs:/app/tracker-gate-v541h/logs"
    links:
      - router
      - redis
    depends_on:
      - router
    environment:
      - gateId=${gateId}
      - routeHost=${routeHost}
      - redisHost=${redisHost}
      - redisPort=${redisPort}
      - redisPasswd=${redisPasswd}
      - kafkaHost=${kafkaHost}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      - kafkaConsumerGroup=${kafkaConsumerGroup}
      - checkDeviceImport=${checkDeviceImport}
      - reloadImei=${reloadImei}
      # Enable(true)/Disable(false) metric collection in IoTHub's monitoring settings
      - collectIothubMetric=${collectIothubMetric}
      # If router initialization fails, wait for 3 seconds and retry
      - hbConnectionFailedSleep=${hbConnectionFailedSleep}
    networks:
      - backend
  jimi-gateway-450:
    restart: always
    container_name: jimi-gateway-450
    image: hb.jimiops.top/iothub/tracker-gate-iothub-c450_sa:76268425
    # ports:
    #   - "21122:21121"
    volumes:
      - "/iothub/license/:/app/tracker-gate-iothub-c450/conf/license/"
      - "/iothub/gate-iothub-c450/logs:/app/tracker-gate-iothub-c450/logs"
    links:
      - router
      - redis
    depends_on:
      - router
    environment:
      - gateId=${gateId}
      - routeHost=${routeHost}
      - redisHost=${redisHost}
      - redisPort=${redisPort}
      - redisPasswd=${redisPasswd}
      - kafkaHost=${kafkaHost}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      - kafkaConsumerGroup=${kafkaConsumerGroup}
      - kafkaEnable=${kafkaEnable}
      - connectTimeout=${connectTimeout}
      - readTimeOut=${readTimeOut}
      - writeTimeOut=${writeTimeOut}
      - newImeiRule=${newImeiRule}
       # Whether clear the uploaded media cache data when device logging in again. true: clear; false: not clear
      - loginCleanMediaCache=${loginCleanMediaCache}
      - checkDeviceImport=${checkDeviceImport}
      - reloadImei=${reloadImei}
      # Enable(true)/Disable(false) metric collection in IoTHub's monitoring settings
      - collectIothubMetric=${collectIothubMetric}
      # If router initialization fails, wait for 3 seconds and retry
      - hbConnectionFailedSleep=${hbConnectionFailedSleep}
    networks:
      - backend
  iothub-media:
    restart: always
    container_name: iothub-media
    tty: true
    stdin_open: true
    privileged: true
    image: hb.jimiops.top/iothub/iothub-media:9b34791b
    deploy:
      resources:
         limits:
            cpus: '2'
            memory: 4G
         reservations:
            memory: 2G
    # ports:
    #   - "8881:8880"
    #   - "1936:1935"
    #   - "10002:10000"
    #   - "10003:10001"
    environment:
      - newImeiRule=true
    volumes:
      - "./iothub-media/log:/log"
      - "./license/jimi-license.lic:/jimi-license.lic"
      # Please place any relevant certificates in folder:/iothub/iothub-media/cer/
      - "./iothub-media/cer/:/cer"
      #- "/mnt/iothub/93test.pl2:/ssl.pl2"
    networks:
      - backend
  jimi-data:
    restart: always
    container_name: jimi-data
    image: hb.jimiops.top/iothub/tracker-data-mongo_sa:76268425
    volumes:
      - "/iothub/jimi-data/:/app/tracker-data-mongo/logs"
    links:
      - kafka
      - mongodb
    depends_on:
      - kafka
      - mongodb
    environment:
    #This URL isused to receive data parsed by LBS/WIFI. Please refer to 1.1.3 pushgps for thedata format. This function involves LBS value-added services and requiresadditional charges!!!
    #After opening the LBS service, it should be customers' actual address!!!
#      - pushLbsWifiURL=http://xxx
#      - pushLbsWifiToken=a12341234123
    #LBS value-added service, please contact customer service to open!
#      - lbsWifiServiceURL=http://xxx
#      - lbsWifiServiceToken=a12341234123
      - kafka=${kafka}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      - mongoHost=${mongoHost}
      - mongoPort=${mongoPort}
      - mongoUser=${mongoUser}
      - mongoPass=${mongoPass}
      - mongoTtlday=${mongoTtlday}
    networks:
      - backend
  jimi-tracker-gate-upload:
    restart: always
    container_name: jimi-tracker-gate-upload
    image: hb.jimiops.top/iothub/tracker-gate-upload_sa:76268425
    # ports:
    #   - "21188:21188"
    volumes:
      - "/iothub/jimi-tracker-gate-upload:/app/tracker-gate-upload/logs"
    depends_on:
      - redis
      - kafka
    environment:
      - redisHost=${redisHost}
      - redisPasswd=${redisPasswd}
      - redisPort=${redisPort}
      - kafkaUrl=${kafkaUrl}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
      - newImeiRule=${newImeiRule}
      ##This pushUploadStatusURL is used to receive the results of file push. The interfacerefers to pushIothubEvent. It should be customers' actual URL!!!
      - pushUploadStatusURL=${pushUploadStatusURL}
      - pushUploadStatusToken=${pushUploadStatusToken}
      - connectTimeout=${connectTimeout}
      - readTimeOut=${readTimeOut}
      - writeTimeOut=${writeTimeOut}
      #HTTP push data encrypted switch
      - httpPushEncrypt=${httpPushEncrypt}
      ##Encryption Key
      - httpPushSecret=${httpPushSecret}
    networks:
      - backend
  jimi-tracker-upload-process:
    restart: always
    container_name: jimi-tracker-upload-process
    image: hb.jimiops.top/iothub/tracker-upload-process_sa:76268425
    volumes:    
      - "/iothub/jimi-upload-process/logs:/app/tracker-upload-process/logs"
      - "/iothub/jimi-upload-process/uploadFile:/temp"
    depends_on:
      - redis
      - kafka
    environment:
      - redisHost=${redisHost}
      - redisPasswd=${redisPasswd}
      - redisPort=${redisPort}
      - kafkaUrl=${kafkaUrl}
      - kafkaAuthSwitch=${kafkaAuthSwitch}
      - kafkaAuthUserName=${kafkaAuthUserName}
      - kafkaAuthPassword=${kafkaAuthPassword}
    networks:
      - backend
  router:
    restart: always
    container_name: router
    image: hb.jimiops.top/iothub/tracker-route-server_sa:0d70cf5f
    # ports:
    #   - "21200:21200"
    volumes:
      - "/iothub/router/logs:/app/tracker-route-server/logs"
    depends_on:
      - redis
    environment:
      - redisHost=${redisHost}
      - redisPasswd=${redisPasswd}
      - redisPort=${redisPort}
      - loginRedisDB=${loginRedisDB}
    networks:
      - backend
networks:
  backend:
    name: backend
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: ${SUBNET_REDE}